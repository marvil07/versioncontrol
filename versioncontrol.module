<?php
// $Id$
/**
 * @file
 * Version Control API - An interface to version control systems
 * whose functionality is provided by pluggable back-end modules.
 *
 * Copyright 2006, 2007 Derek Wright ("dww" , http://drupal.org/user/46549)
 * Copyright 2007, 2008, 2009 by Jakob Petsovits ("jpetso", http://drupal.org/user/56020)
 */

/**
 * @name backend capabilities
 * Optional capabilities that backend modules can provide.
 */
//@{
define('VERSIONCONTROL_CAPABILITY_ATOMIC_COMMITS',          1);
define('VERSIONCONTROL_CAPABILITY_COMMIT_RESTRICTIONS',     2);
define('VERSIONCONTROL_CAPABILITY_BRANCH_TAG_RESTRICTIONS', 3);
define('VERSIONCONTROL_CAPABILITY_DIRECTORY_REVISIONS',     4);
//@}

/**
 * @name VCS backend flags
 * Flags that backends can set to specify if Version Control API
 * should do work for them.
 */
//@{
define('VERSIONCONTROL_FLAG_AUTOADD_REPOSITORIES',      1);
//@}

/**
 * @name VCS actions
 * for a single item (file or directory) in a commit, or for branches and tags.
 */
//@{
define('VERSIONCONTROL_ACTION_ADDED',    1);
define('VERSIONCONTROL_ACTION_MODIFIED', 2);
define('VERSIONCONTROL_ACTION_MOVED',    3); //< == renamed
define('VERSIONCONTROL_ACTION_COPIED',   4);
define('VERSIONCONTROL_ACTION_MERGED',   5);
define('VERSIONCONTROL_ACTION_DELETED',  6);
define('VERSIONCONTROL_ACTION_REPLACED', 7);
define('VERSIONCONTROL_ACTION_OTHER',    8); //< for example, SVN revprop-only changes
//@}

/**
 * @name VCS flag for operation item database entries
 * The flag for operation item database entries, specifying whether an item
 * is actually a direct "member" item of that operation or just a cached
 * source item that speeds up operation queries. (Background: we want some
 * source items to be considered when the caller passes a 'paths' constraint,
 * but joining those is unnecessarily inefficient. Therefore, searched source
 * items get directly included in the {versioncontrol_operation_items} table.)
 * This is an implementation detail, the API user won't get to see this. Ever.
 */
//@{
define('VERSIONCONTROL_OPERATION_MEMBER_ITEM',          1);
define('VERSIONCONTROL_OPERATION_CACHED_AFFECTED_ITEM', 2);
//@}

/**
 * @name Constraint 'cardinality' key
 * Allowed values for the 'cardinality' key in constraint descriptions
 * provided by hook_versioncontrol_operation_constraint_info().
 */
//@{
define('VERSIONCONTROL_CONSTRAINT_MULTIPLE',           1); // default
define('VERSIONCONTROL_CONSTRAINT_SINGLE',             2);
define('VERSIONCONTROL_CONSTRAINT_SINGLE_OR_MULTIPLE', 3);
//@}

/**
 * @name User relation constraints
 * Allowed values for use with the 'user_relation' constraint in
 * versioncontrol_get_operations() queries.
 */
//@{
define('VERSIONCONTROL_USER_ASSOCIATED',        1);
define('VERSIONCONTROL_USER_ASSOCIATED_ACTIVE', 2);
//@}

/** Used internally by the repository and account admin pages. Private constant. */
define('VERSIONCONTROL_FORM_CREATE', FALSE);

//TODO: define if we want to do the load each time, per use, or all-in-one like views.inc
require_once drupal_get_path('module', 'versioncontrol') .'/includes/VersioncontrolAccount.php';

/**
 * Implementation of hook_init():
 * Code that is run on every page request, except for cached ones.
 */
function versioncontrol_init() {
  // The backend-only part of the API.
  module_load_include('inc', 'versioncontrol', 'versioncontrol-backend');
}

/**
 * Implementation of hook_theme().
 */
function versioncontrol_theme() {
  $theme = array();
  $theme['versioncontrol_account_username'] = array(
    'arguments' => array('uid', 'username', 'repository', 'options' => NULL),
  );
  $theme['versioncontrol_user_statistics_table'] = array(
    'arguments' => array('statistics', 'options'),
  );
  $theme['versioncontrol_user_statistics_item_list'] = array(
    'arguments' => array('statistics', 'more_link'),
  );
  $theme['versioncontrol_user_statistics_account'] = array(
    'arguments' => array('user_stats'),
  );
  return $theme;
}

/**
 * Implementation of hook_user():
 * Register additional user account edit tabs,
 * and delete VCS accounts when the associated user account is deleted.
 */
function versioncontrol_user($type, &$edit, &$user, $category = NULL) {
  switch ($type) {
    case 'categories':
      $categories = array();
      $categories[] = array(
        'name' => 'versioncontrol',
        // user_menu() pipes 'title' though check_plain() already.
        'title' => 'Repository accounts',
        'weight' => 99,
      );
      return $categories;

    case 'delete':
      $accounts = VersioncontrolAccount::getAccounts(array('uids' => array($user->uid)), TRUE);
      if (empty($accounts)) {
        return;
      }
      $accounts_flat = array();
      $repo_ids = array();

      foreach ($accounts as $uid => $usernames_by_repository) {
        foreach ($usernames_by_repository as $repo_id => $account) {
          $accounts_flat[] = array('uid' => $uid, 'username' => $account->vcs_username, 'repo_id' => $repo_id);
          $repo_ids[] = $repo_id;
        }
      }
      $repositories = VersioncontrolRepository::getRepositories(array('repo_ids' => $repo_ids));

      foreach ($accounts_flat as $account) {
        if (isset($repositories[$account['repo_id']])) {
          versioncontrol_delete_account(
            $repositories[$account['repo_id']], $account['uid'], $account['username']
          );
        }
      }
      return;
  }
}

/**
 * Implementation of hook_menu().
 */
function versioncontrol_menu() {
  $items = array();

  $admin = array(
    'page callback' => 'drupal_get_form',
    'access arguments' => array('administer version control systems'),
    'file' => 'versioncontrol.admin.inc',
  );

  // If Version Control API is used without the Project module,
  // we need to define our own version of /admin/project
  // so the rest of our admin pages all work.
  if (!module_exists('project')) {
    $items['admin/project'] = array(
      'title' => 'Project administration',
      'description' => 'Administrative interface for project management and related modules.',
      'position' => 'left',
      'weight' => 3,
      'page callback' => 'system_admin_menu_block_page',
      'access arguments' => array('administer site configuration'),
      'file' => 'system.admin.inc',
      'file path' => drupal_get_path('module', 'system'),
    );
  }

  $items['admin/project/versioncontrol-settings'] = array(
    'title' => 'Version control settings',
    'description' => 'Configure settings for Version Control API and related modules.',
    'page arguments' => array('versioncontrol_admin_settings'),
    'type' => MENU_NORMAL_ITEM,
  ) + $admin;
  $items['admin/project/versioncontrol-settings/general'] = array(
    'title' => 'General',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );

  $items['admin/project/versioncontrol-repositories'] = array(
    'title' => 'VCS repositories',
    'description' => 'Define and configure what version control repositories are connected to your site, and how to integrate each repository with repository browser tools such as ViewVC or WebSVN.',
    'page arguments' => array('versioncontrol_admin_repository_list'),
  ) + $admin;

  $weight = 1;
  $items['admin/project/versioncontrol-repositories/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => $weight,
  );

  // former !$may_cache
  /// TODO: Backend specific stuff was done in !$may_cache, as it once
  ///       screwed up after activating a new backend in admin/build/modules.
  ///       Make sure this works now.
  foreach (versioncontrol_get_backends() as $vcs => $backend) {
    $items['admin/project/versioncontrol-repositories/add-'. $vcs] = array(
      'title' => 'Add @vcs repository',
      'title arguments' => array('@vcs' => $backend['name']),
      'page arguments' => array('versioncontrol_admin_repository_edit',
        VERSIONCONTROL_FORM_CREATE, $vcs
      ),
      'type' => MENU_LOCAL_TASK,
      'weight' => ++$weight,
    ) + $admin;
  }
  // end former !$may_cache

  $items['admin/project/versioncontrol-repositories/edit/%versioncontrol_repository'] = array(
    'title' => 'Edit repository',
    'page arguments' => array('versioncontrol_admin_repository_edit', 4),
    'type' => MENU_CALLBACK,
  ) + $admin;
  $items['admin/project/versioncontrol-repositories/delete/%versioncontrol_repository'] = array(
    'title' => 'Delete repository',
    'page arguments' => array('versioncontrol_admin_repository_delete_confirm', 4),
    'type' => MENU_CALLBACK,
  ) + $admin;

  $items['admin/project/versioncontrol-accounts'] = array(
    'title' => 'VCS accounts',
    'description' => 'Manage associations of Drupal users to VCS user accounts.',
    'page arguments' => array('versioncontrol_admin_account_list_form'),
    'type' => MENU_NORMAL_ITEM,
  ) + $admin;
  $items['admin/project/versioncontrol-accounts/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => 0,
  );

  // former !$may_cache
  /// TODO: Backend specific stuff was done in !$may_cache, as it once
  ///       screwed up after activating a new backend in admin/build/modules.
  ///       Make sure this works now.
  // TODO (sdb): this should all be reworked using a version of the loader that
  // takes additional arguments for implementation checking.
  foreach (versioncontrol_get_backends() as $vcs => $backend) {
    if (versioncontrol_backend_implements($vcs, 'import_accounts')) {
      $items['admin/project/versioncontrol-accounts/import'] = array(
        'title' => 'Import',
        'description' => 'Import an existing set of VCS user accounts.',
        'page arguments' => array('versioncontrol_admin_account_import_form'),
        'type' => MENU_LOCAL_TASK,
        'weight' => 2,
      ) + $admin;
    }
    if (versioncontrol_backend_implements($vcs, 'export_accounts')) {
      $items['admin/project/versioncontrol-accounts/export'] = array(
        'title' => 'Export',
        'description' => 'Export VCS user accounts of a specific repository.',
        'page arguments' => array('versioncontrol_admin_account_export_form'),
        'type' => MENU_LOCAL_TASK,
        'weight' => 3,
      ) + $admin;
      $items['admin/project/versioncontrol-accounts/export/%versioncontrol_repository'] = array(
        'title' => 'Export',
        'page callback' => 'versioncontrol_admin_account_export_page',
        'page arguments' => array(4),
        'type' => MENU_CALLBACK,
      ) + $admin;
    }
  }
  // end former !$may_cache

  // Account registration and editing pages for the regular user.
  $items['versioncontrol/register'] = array(
    'title' => 'Get commit access',
    'page callback' => 'versioncontrol_account_register_page',
    'access callback' => TRUE, // access checking is done in the page callback
    'file' => 'versioncontrol.pages.inc',
    'type' => MENU_SUGGESTED_ITEM,
  );
  $items['user/%versioncontrol_user_accounts/edit/versioncontrol'] = array(
    // Load with $include_unauthorized == TRUE, so that the user can inspect
    // his/her VCS accounts even if they are not approved by the admin yet.
    'load arguments' => array(TRUE),
    'title callback' => 'versioncontrol_user_accounts_title_callback',
    'title arguments' => array(1),
    'page callback' => 'versioncontrol_account_page',
    'page arguments' => array(1),
    'access callback' => 'versioncontrol_private_account_access',
    'access arguments' => array(1),
    'file' => 'versioncontrol.pages.inc',
    'weight' => 99,
    'type' => MENU_LOCAL_TASK,
  );

  // Autocomplete callback for Drupal usernames that have access to
  // the repo_id given in arg(3). (No need to fetch the full repository,
  // as the callback uses a raw & safe database query anyways.)
  $items['versioncontrol/user/autocomplete'] = array(
    'title' => 'Version control user autocomplete',
    'page callback' => 'versioncontrol_user_autocomplete',
    'access callback' => 'versioncontrol_user_access',
    'type' => MENU_CALLBACK,
  );

  return $items;
}

/**
 * Custom access callback, determining if the current user (or the one given
 * in @p $account, if set) is permitted to administer version control system
 * functionality.
 */
function versioncontrol_admin_access($account = NULL) {
  return user_access('administer version control systems', $account);
}

/**
 * Custom access callback, determining if the current user (or the one given
 * in @p $account, if set) is permitted to use version control system
 * functionality.
 */
function versioncontrol_user_access($account = NULL) {
  return user_access('use version control systems', $account)
    || user_access('administer version control systems', $account);
}

/**
 * Custom access callback, determining if the current user (or the one given
 * in @p $account, if set) is permitted to view version control account
 * settings of the user specified the first user id in @p $vcs_accounts.
 * (We take that parameter because it's what the '%versioncontrol_user_accounts'
 * wildcard returns.)
 */
function versioncontrol_private_account_access($vcs_accounts, $account = NULL) {
  $viewed_uid = key($vcs_accounts);
  if (!$viewed_uid) {
    return FALSE;
  }
  if (is_null($account)) {
    global $user;
    $account = clone $user;
  }
  return ($viewed_uid == $account->uid && user_access('use version control systems', $account))
    || user_access('administer version control systems', $account);
}

/**
 * Title callback for the "user/%versioncontrol_user_accounts/edit/versioncontrol" tab.
 */
function versioncontrol_user_accounts_title_callback($accounts) {
  $usernames = array();
  foreach ($accounts as $uid => $user_accounts) {
    foreach ($user_accounts as $repo_id => $username) {
      $usernames[] = $username;
    }
  }
  $repositories = VersioncontrolRepository::getRepositories(array(
    'repo_ids' => array_keys(reset($accounts)), // a.k.a. list of account repo_ids
  ));
  $vcses = array();
  foreach ($repositories as $repository) {
    $vcses[$repository['vcs']] = TRUE;
  }
  if (count($vcses) == 1) {
    $backends = versioncontrol_get_backends();
    $vcs = key($vcses);
    return check_plain($backends[$vcs]['name']);
  }
  return t('Repository accounts');
}

/**
 * Implementation of hook_perm().
 */
function versioncontrol_perm() {
  return array(
    'administer version control systems',
    'use version control systems',
  );
}

/**
 * Menu wildcard loader for repository ids ('%versioncontrol_repository').
 * Use this only for menu paths - if you want to retrieve a repository with
 * your own code, use versioncontrol_get_repository() instead.
 * (Yeah, I know duplicate functions are bad. Hopefully we can sort this out
 * when repositories are made into real objects, as
 * versioncontrol_get_repository() will be a static class method then.)
 */
function versioncontrol_repository_load($repo_id) {
  $repository = VersioncontrolRepository::getRepository($repo_id);
  return empty($repository) ? FALSE : $repository;
}

/**
 * Menu wildcard loader for '%versioncontrol_user_accounts':
 * Load all VCS accounts of a given user (in the format that
 * VersioncontrolAccount::getAccounts() returns) and return either that
 * or FALSE if no VCS accounts exist for this user.
 *
 * @access public
 * @static
 * @param $uid
 *   Drupal user id of the user whose VCS accounts should be loaded.
 * @param $include_unauthorized
 *   Will be passed on to VersioncontrolAccount::getAccounts(), see the
 *   API documentation of that function.
 */
function versioncontrol_user_accounts_load($uid, $include_unauthorized = FALSE) {
  $accounts = VersioncontrolAccount::getAccounts(array('uids' => array($uid)), $include_unauthorized);
  return empty($accounts) ? FALSE : $accounts;
}


// API functions start here.

/**
 * Get a list of all backends and more detailed information about each of them.
 *
 * @return
 *   A structured array containing information about all known backends.
 *   Array keys are the unique string identifier of the version control system.
 *   The corresponding array values are again structured arrays and consist
 *   of elements with the following keys:
 *
 *   - 'name': The user-visible name of the VCS.
 *   - 'description': A short description of the backend, if possible
 *        not longer than one or two sentences.
 *   - 'capabilities': An array listing optional capabilities, in addition
 *        to the required functionality like retrieval of detailed
 *        commit information. Array values can be an arbitrary combination
 *        of VERSIONCONTROL_CAPABILITY_* values. If no additional capabilities
 *        are supported by the backend, this array will be empty.
 *   - 'flags': An array listing which tables should be managed by
 *        Version Control API instead of doing it manually in the backend.
 *        Array values can be an arbitrary combination of VERSIONCONTROL_FLAG_*
 *        values. If no array additions should be automatically managed,
 *        this array will be empty.
 *
 *   If no single backends can be found, an empty array is returned.
 *
 *   A real-life example of such a result array can be found
 *   in the FakeVCS example module.
 */
function versioncontrol_get_backends() {
  static $backends;

  if (!isset($backends)) {
    $backends = module_invoke_all('versioncontrol_backends');
  }
  return $backends;
}

/**
 * Convenience function, retrieving the backend information array for a
 * single repository. So, the result is one of the elements in the result array
 * of versioncontrol_get_backends(). As versioncontrol_get_repositories() only
 * returns repositories for backends that actually exist, this function can be
 * trusted to always return a valid backend array.
 */
function versioncontrol_get_backend($repository) {
  $backends = versioncontrol_get_backends();
  return $backends[$repository['vcs']];
}

/**
 * Determine if a given backend module implements a specific backend function.
 *
 * @param $vcs
 *   The unique string identifier of the version control system.
 * @param $function
 *   The function name without module prefix.
 *
 * @return
 *   TRUE if the backend implements the function, or FALSE otherwise.
 */
function versioncontrol_backend_implements($vcs, $function) {
  if (function_exists('versioncontrol_'. $vcs .'_'. $function)) {
    return TRUE;
  }
  return FALSE;
}

/**
 * Call a function from the desired VCS backend and return its result value.
 *
 * @param $vcs
 *   The unique string identifier of the version control system.
 * @param $function
 *   The function name without module prefix.
 * @param $args
 *   An array of arguments that will be passed to the backend function.
 *
 * @return
 *   Returns the result of the backend function. The result value of calls
 *   where the backend function has no implementation is undefined, as they
 *   are supposed to be checked with versioncontrol_backend_implements()
 *   before those functions are called.
 */
function _versioncontrol_call_backend($vcs, $function, $args) {
  return call_user_func_array('versioncontrol_'. $vcs .'_'. $function, $args);
}

/**
 * Determine all user account authorization methods
 * (free for all, only admin may create accounts, per-repository approval, ...)
 * by invoking hook_versioncontrol_authorization_methods().
 *
 * @return
 *   A structured array with the unique string identifier of the method as keys
 *   and the user-visible description (wrapped in t()) as values.
 */
function versioncontrol_get_authorization_methods() {
  static $methods;

  if (!isset($methods)) {
    $methods = module_invoke_all('versioncontrol_authorization_methods');
  }
  return $methods;
}

/**
 * Implementation of hook_versioncontrol_authorization_methods().
 *
 * @return
 *   A structured array containing information about authorization methods
 *   provided by this module, wrapped in a structured array. Array keys are
 *   the unique string identifiers of each authorization method, and
 *   array values are the user-visible method descriptions (wrapped in t()).
 */
function versioncontrol_versioncontrol_authorization_methods() {
  return array(
    'versioncontrol_admin' => t('Only administrators can create accounts'),
    'versioncontrol_none' => t('No approval required'),
  );
}

function _versioncontrol_get_fallback_authorization_method() {
  return 'versioncontrol_admin';
}

/**
 * Assemble a list of query constraints given as string array that's
 * supposed to be imploded with an SQL "AND", and a $params array containing
 * the corresponding parameter values for all the '%d' and '%s' placeholders.
 */
function _versioncontrol_construct_repository_constraints($constraints, $backends) {
  $and_constraints = array();
  $params = array();

  // Filter out repositories of which the corresponding backend is not enabled,
  // and handle the 'vcs' constraint at the same time.
  $placeholders = array();
  $vcses = array_keys($backends);
  if (isset($constraints['vcs'])) {
    $vcses = array_intersect($vcses, $constraints['vcs']);
  }
  if (empty($vcses)) {
    $and_constraints[] = 'FALSE'; // no backends are enabled of those that have been requested
  }
  else {
    foreach ($vcses as $vcs) {
      $placeholders[] = "'%s'";
      $params[] = $vcs;
    }
    $and_constraints[] = 'r.vcs IN ('. implode(',', $placeholders) .')';
  }

  if (isset($constraints['repo_ids'])) {
    if (empty($constraints['repo_ids'])) {
      $and_constraints[] = 'FALSE';
    }
    else {
      $placeholders = array();
      foreach ($constraints['repo_ids'] as $repo_id) {
        $placeholders[] = '%d';
        $params[] = $repo_id;
      }
      $and_constraints[] = 'r.repo_id IN ('. implode(',', $placeholders) .')';
    }
  }

  if (isset($constraints['names'])) {
    if (empty($constraints['names'])) {
      $and_constraints[] = 'FALSE';
    }
    else {
      $placeholders = array();
      foreach ($constraints['names'] as $name) {
        $placeholders[] = "'%s'";
        $params[] = $name;
      }
      $and_constraints[] = 'r.name IN ('. implode(',', $placeholders) .')';
    }
  }

  return array($and_constraints, $params);
}

/**
 * Execute a query with either db_query(), db_query_range() or pager_query().
 * Which one of those is called, and with which parameters, is specified by the
 * @p $options array, see versioncontrol_get_operations() for a description of
 * possible array keys and option values.
 */
function _versioncontrol_query($query, $params, $options) {
  if (isset($options['query_type']) && $options['query_type'] == 'pager') {
    $element = isset($options['pager_element']) ? $options['pager_element'] : 0;
    return pager_query($query, $options['count'], $element, NULL, $params);
  }
  elseif (isset($options['query_type']) && $options['query_type'] == 'range') {
    return db_query_range($query, $params, $options['from'], $options['count']);
  }
  else {
    return db_query($query, $params);
  }
}

/**
 * Implementation of hook_versioncontrol_operation_constraint_info().
 */
function versioncontrol_versioncontrol_operation_constraint_info() {
  return array(
    'vcs' => array('join callback' => 'versioncontrol_table_repositories_join'),
    'vc_op_ids' => array(),
    'revisions' => array(),
    'repo_ids' => array('join callback' => 'versioncontrol_table_repositories_join'),
    'date_lower' => array('cardinality' => VERSIONCONTROL_CONSTRAINT_SINGLE),
    'date_upper' => array('cardinality' => VERSIONCONTROL_CONSTRAINT_SINGLE),
    'uids' => array(),
    'usernames' => array(),
    'user_relation' => array('cardinality' => VERSIONCONTROL_CONSTRAINT_SINGLE),
    'message' => array('cardinality' => VERSIONCONTROL_CONSTRAINT_SINGLE_OR_MULTIPLE),
    'item_revision_ids' => array('join callback' => 'versioncontrol_table_operation_items_join'),
    'item_revisions' => array('join callback' => 'versioncontrol_table_item_revisions_join'),
    'paths' => array('join callback' => 'versioncontrol_table_item_revisions_join'),
    'labels' => array('join callback' => 'versioncontrol_table_labels_join'),
    'tags' => array('join callback' => 'versioncontrol_table_labels_join'),
    'branches' => array('join callback' => 'versioncontrol_table_labels_join'),
    'types' => array(),
  );
}

/**
 * Implementation of hook_versioncontrol_operation_constraints_alter():
 * Include only operations for enabled backends in the query.
 */
function versioncontrol_versioncontrol_operation_constraints_alter($constraints) {
  // Filter out entries of which the corresponding backend is not enabled,
  // and handle the 'vcs' constraint at the same time.
  $backends = versioncontrol_get_backends();
  $vcses = array_keys($backends);

  if (isset($constraints['vcs'])) {
    $vcses = array_intersect($vcses, $constraints['vcs']);
  }
  $constraints['vcs'] = $vcses;
}

/**
 * Filter operations by their associated backend.
 */
function versioncontrol_operation_constraint_vcs($constraint, &$tables, &$and_constraints, &$params) {
  $placeholders = array();
  foreach ($constraint as $vcs) {
    $placeholders[] = "'%s'";
    $params[] = $vcs;
  }
  $and_constraints[] = $tables['versioncontrol_repositories']['alias'] .'.vcs
                        IN ('. implode(',', $placeholders) .')';
}

/**
 * Filter operations by their version control operation id.
 */
function versioncontrol_operation_constraint_vc_op_ids($constraint, &$tables, &$and_constraints, &$params) {
  $placeholders = array();
  foreach ($constraint as $vc_op_id) {
    $placeholders[] = '%d';
    $params[] = $vc_op_id;
  }
  $and_constraints[] = $tables['versioncontrol_operations']['alias'] .'.vc_op_id
                        IN ('. implode(',', $placeholders) .')';
}

/**
 * Filter operations by their revision identifier.
 */
function versioncontrol_operation_constraint_revisions($constraint, &$tables, &$and_constraints, &$params) {
  $placeholders = array();
  foreach ($constraint as $revision) {
    $placeholders[] = "'%s'";
    $params[] = $revision;
  }
  $and_constraints[] = $tables['versioncontrol_operations']['alias'] .'.revision
                        IN ('. implode(',', $placeholders) .')';
}

/**
 * Filter operations by their repository id.
 */
function versioncontrol_operation_constraint_repo_ids($constraint, &$tables, &$and_constraints, &$params) {
  $placeholders = array();
  foreach ($constraint as $repo_id) {
    $placeholders[] = '%d';
    $params[] = $repo_id;
  }
  $and_constraints[] = $tables['versioncontrol_repositories']['alias'] .'.repo_id
                        IN ('. implode(',', $placeholders) .')';
}

/**
 * Filter operations by a lower date bound.
 */
function versioncontrol_operation_constraint_date_lower($constraint, &$tables, &$and_constraints, &$params) {
  $and_constraints[] = '('. $tables['versioncontrol_operations']['alias'] .'.date >= %d)';
  $params[] = $constraint;
}

/**
 * Filter operations by an upper date bound.
 */
function versioncontrol_operation_constraint_date_upper($constraint, &$tables, &$and_constraints, &$params) {
  $and_constraints[] = '('. $tables['versioncontrol_operations']['alias'] .'.date <= %d)';
  $params[] = $constraint;
}

/**
 * Filter operations by their associated Drupal user id.
 */
function versioncontrol_operation_constraint_uids($constraint, &$tables, &$and_constraints, &$params) {
  $placeholders = array();
  foreach ($constraint as $uid) {
    $placeholders[] = '%d';
    $params[] = $uid;
  }
  $and_constraints[] = $tables['versioncontrol_operations']['alias'] .'.uid
                        IN ('. implode(',', $placeholders) .')';
}

/**
 * Filter operations by the VCS username of the operation author.
 */
function versioncontrol_operation_constraint_usernames($constraint, &$tables, &$and_constraints, &$params) {
  $placeholders = array();
  foreach ($constraint as $username) {
    $placeholders[] = "'%s'";
    $params[] = $username;
  }
  $and_constraints[] = $tables['versioncontrol_operations']['alias'] .'.username
                        IN ('. implode(',', $placeholders) .')';
}

/**
 * Filter operations by associated Drupal user status of the operation author.
 */
function versioncontrol_operation_constraint_user_relation($constraint, &$tables, &$and_constraints, &$params) {
  $and_constraints[] = $tables['versioncontrol_operations']['alias'] .'.uid <> 0';

  if ($constraint == VERSIONCONTROL_USER_ASSOCIATED_ACTIVE) {
    versioncontrol_table_users_join($tables);
    $and_constraints[] = $tables['users']['alias'] .'.status = 1';
  }
}

/**
 * Filter operations by their log message.
 */
function versioncontrol_operation_constraint_message($constraint, &$tables, &$and_constraints, &$params) {
  $or_constraints = array();
  foreach ($constraint as $message_part) {
    $or_constraints[] = $tables['versioncontrol_operations']['alias'] .".message LIKE '%s'";
    $params[] = '%'. $message_part .'%';
  }
  $and_constraints[] = '('. implode(' OR ', $or_constraints) .')';
}

/**
 * Filter operations by item_revision_ids of associated items.
 */
function versioncontrol_operation_constraint_item_revision_ids($constraint, &$tables, &$and_constraints, &$params) {
  $or_constraints = array();

  $placeholders = array();
  foreach ($constraint as $item_revision_id) {
    $placeholders[] = '%d';
    $params[] = $item_revision_id;
  }
  $and_constraints[] = $tables['versioncontrol_operation_items']['alias'] .'.item_revision_id
                        IN ('. implode(',', $placeholders) .')';

  // Exact search for target items, no fuzzy source item path results.
  $params[] = VERSIONCONTROL_OPERATION_MEMBER_ITEM;
  $and_constraints[] = $tables['versioncontrol_operation_items']['alias'] .'.type = %d';
}

/**
 * Filter operations by revision identifiers of associated items.
 */
function versioncontrol_operation_constraint_item_revisions($constraint, &$tables, &$and_constraints, &$params) {
  $or_constraints = array();

  $placeholders = array();
  foreach ($constraint as $revision) {
    $placeholders[] = "'%s'";
    $params[] = $revision;
  }
  $and_constraints[] = $tables['versioncontrol_item_revisions']['alias'] .'.revision IN ('. implode(',', $placeholders) .')';

  // Exact search for target items, no fuzzy source item path results.
  $params[] = VERSIONCONTROL_OPERATION_MEMBER_ITEM;
  $and_constraints[] = $tables['versioncontrol_operation_items']['alias'] .'.type = %d';
}

/**
 * Filter operations by item paths of associated items.
 */
function versioncontrol_operation_constraint_paths($constraint, &$tables, &$and_constraints, &$params) {
  $or_constraints = array();

  foreach ($constraint as $path) {
    $current_path = $path;
    $placeholders = array();

    // Both the given path and all its parent directories are included in the query.
    while (TRUE) {
      $placeholders[] = "'%s'";
      $params[] = $current_path;

      if ($current_path == dirname($current_path)) {
        break; // we reached the root directory, '/'
      }
      $current_path = dirname($current_path);
    }
    $or_constraints[] = $tables['versioncontrol_item_revisions']['alias'] .'.path IN ('. implode(',', $placeholders) .')';

    // Also include any children paths of the given one
    // (will only yield results for directory paths).
    $or_constraints[] = $tables['versioncontrol_item_revisions']['alias'] .".path LIKE '%s'";
    $params[] = $path . (($path[strlen($path)-1] == '/') ? '%' : '/%');
  }
  $and_constraints[] = '('. implode(' OR ', $or_constraints) .')';
}

/**
 * Filter operations by associated label names (both branches and tags).
 */
function versioncontrol_operation_constraint_labels($constraint, &$tables, &$and_constraints, &$params) {
  $or_constraints = array();
  foreach ($constraint as $label_name) {
    $or_constraints[] = $tables['versioncontrol_labels']['alias'] .".name = '%s'";
    $params[] = $label_name;
  }
  $and_constraints[] = '('. implode(' OR ', $or_constraints) .')';
}

/**
 * Filter operations by associated tag names.
 */
function versioncontrol_operation_constraint_tags($constraint, &$tables, &$and_constraints, &$params) {
  $or_constraints = array();
  foreach ($constraint as $label_name) {
    $or_constraints[] = $tables['versioncontrol_labels']['alias'] .".name = '%s'";
    $params[] = $label_name;
  }
  $and_constraints[] = '(('. implode(' OR ', $or_constraints) .') AND '.
    $tables['versioncontrol_labels']['alias'] .'.type = %d)';
  $params[] = VERSIONCONTROL_OPERATION_TAG;
}

/**
 * Filter operations by associated branch names.
 * (Applies to both branch operations and commits).
 */
function versioncontrol_operation_constraint_branches($constraint, &$tables, &$and_constraints, &$params) {
  $or_constraints = array();
  foreach ($constraint as $label_name) {
    $or_constraints[] = $tables['versioncontrol_labels']['alias'] .".name = '%s'";
    $params[] = $label_name;
  }
  $and_constraints[] = '(('. implode(' OR ', $or_constraints) .') AND '.
    $tables['versioncontrol_labels']['alias'] .'.type = %d)';
  $params[] = VERSIONCONTROL_OPERATION_BRANCH;
}

/**
 * Filter operations by their operation type. As noted in the API documentation
 * for versioncontrol_get_operations(), this filter is kinda smart and also
 * includes commits for version control systems like Subversion when a branch
 * or tag is affected by that commit.
 */
function versioncontrol_operation_constraint_types($constraint, &$tables, &$and_constraints, &$params) {
  $or_constraints = array();

  if (in_array(VERSIONCONTROL_OPERATION_COMMIT, $constraint)) {
    $or_constraints[] = $tables['versioncontrol_operations']['alias'] .'.type = %d';
    $params[] = VERSIONCONTROL_OPERATION_COMMIT;
  }
  if (in_array(VERSIONCONTROL_OPERATION_BRANCH, $constraint)) {
    versioncontrol_table_labels_join($tables);
    $or_constraints[] = '('.
      $tables['versioncontrol_labels']['alias'] .'.type = %d AND '.
      $tables['versioncontrol_operation_labels']['alias'] .'.action <> %d
    )';
    $params[] = VERSIONCONTROL_OPERATION_BRANCH; // label.type
    // oplabel.action is != normal commits, we don't want those:
    $params[] = VERSIONCONTROL_ACTION_MODIFIED;
  }
  if (in_array(VERSIONCONTROL_OPERATION_TAG, $constraint)) {
    versioncontrol_table_labels_join($tables);
    $or_constraints[] = '('.
      $tables['versioncontrol_labels']['alias'] .'.type = %d AND '.
      $tables['versioncontrol_operation_labels']['alias'] .'.action <> %d
    )';
    $params[] = VERSIONCONTROL_OPERATION_TAG; // label.type
    // oplabel.action is != normal commits, we don't want those:
    $params[] = VERSIONCONTROL_ACTION_MODIFIED;
  }
  $and_constraints[] = '('. implode(' OR ', $or_constraints) .')';
}

/**
 * Take an existing @p $tables array and add the table join for
 * {versioncontrol_repositories}. Only meant to be used within a
 * constraint construction callback.
 */
function versioncontrol_table_repositories_join(&$tables) {
  if (!isset($tables['versioncontrol_repositories'])) {
    $tables['versioncontrol_repositories'] = array(
      'alias' => 'r',
      'join_on' => 'op.repo_id = r.repo_id',
    );
  }
}

/**
 * Take an existing @p $tables array and add the table join for {users} on
 * {versioncontrol_operations}.uid. Only meant to be used within a
 * constraint construction callback.
 */
function versioncontrol_table_users_join(&$tables) {
  if (!isset($tables['users'])) {
    $tables['users'] = array(
      'alias' => 'user',
      'join_on' => 'op.uid = user.uid',
    );
  }
}

/**
 * Take an existing @p $tables array and add the table joins for
 * {versioncontrol_operation_labels} and {versioncontrol_labels}.
 * Only meant to be used within a constraint construction callback.
 */
function versioncontrol_table_labels_join(&$tables) {
  if (!isset($tables['versioncontrol_operation_labels'])) {
    $tables['versioncontrol_operation_labels'] = array(
      'alias' => 'oplabel',
      'join_on' => $tables['versioncontrol_operations']['alias'] .'.vc_op_id = oplabel.vc_op_id',
    );
    $tables['versioncontrol_labels'] = array(
      'alias' => 'label',
      'join_on' => 'oplabel.label_id = label.label_id',
    );
  }
}

/**
 * Take an existing @p $tables array and add the table join for
 * {versioncontrol_operation_items}.
 * Only meant to be used within a constraint construction callback.
 */
function versioncontrol_table_operation_items_join(&$tables) {
  if (!isset($tables['versioncontrol_operation_items'])) {
    $tables['versioncontrol_operation_items'] = array(
      'alias' => 'opitem',
      'join_on' => $tables['versioncontrol_operations']['alias'] .'.vc_op_id = opitem.vc_op_id',
    );
  }
}

/**
 * Take an existing @p $tables array and add the table joins for
 * {versioncontrol_operation_labels} and {versioncontrol_labels}.
 * Only meant to be used within a constraint construction callback.
 */
function versioncontrol_table_item_revisions_join(&$tables) {
  if (!isset($tables['versioncontrol_item_revisions'])) {
    versioncontrol_table_operation_items_join(&$tables);

    $tables['versioncontrol_item_revisions'] = array(
      'alias' => 'ir',
      'join_on' => 'opitem.item_revision_id = ir.item_revision_id',
    );
  }
}

/**
 * Return a subset of the given operations according to the
 * $page and $limit values.
 */
function _versioncontrol_page_operations($operations, $page, $limit) {
  $i = 0;
  $paged_operations = array();
  foreach ($operations as $operation) {
    if ($i >= ($page * $limit) && $i < (($page+1) * $limit)) {
      $paged_operations[] = $operation;
    }
    ++$i;
  }
  return $paged_operations;
}


/**
 * Retrieve additional information about the origin of a given set of items.
 *
 * @param $repository
 *   The repository that the items are located in.
 * @param $items
 *   An array of item arrays, for example as returned by
 *   versioncontrol_get_operation_items().
 *
 * @return
 *   This function does not have a return value; instead, it alters the
 *   given item arrays and adds additional information about their origin.
 *   The following elements will be set for all items whose source items
 *   could be retrieved.
 *
 *   - 'action': Specifies how the item was changed.
 *        One of the predefined VERSIONCONTROL_ACTION_* values.
 *   - 'source_items': An array with the previous revision(s) of the affected
 *        item. Empty if 'action' is VERSIONCONTROL_ACTION_ADDED. The key for
 *        all items in this array is the respective item path.
 *   - 'replaced_item': The previous but technically unrelated item at the
 *        same location as the current item. Only exists if this previous item
 *        was deleted and replaced by a different one that was just moved
 *        or copied to this location.
 *   - 'line_changes': Only exists if line changes have been recorded for this
 *        action - if so, this is an array containing the number of added lines
 *        in an element with key 'added', and the number of removed lines in
 *        the 'removed' key.
 */
function versioncontrol_fetch_source_items($repository, &$items) {
  if (empty($items)) {
    return;
  }
  $placeholders = array();
  $ids = array();
  $item_keys = array();

  foreach ($items as $key => $item) {
    // If we don't yet know the item_revision_id (required for db queries), try
    // to retrieve it. If we don't find it, we can't fetch this item's sources.
    if ($item->fetchItemRevisionId()) {
      $placeholders[] = '%d';
      $ids[] = $item->item_revision_id;
      $item_keys[$item->item_revision_id] = $key;
    }
  }
  if (empty($ids)) {
    return;
  }

  $result = db_query(
    'SELECT sit.item_revision_id, sit.source_item_revision_id, sit.action,
            sit.line_changes_recorded, sit.line_changes_added,
            sit.line_changes_removed, ir.path, ir.revision, ir.type
     FROM {versioncontrol_source_items} sit
      LEFT JOIN {versioncontrol_item_revisions} ir
       ON sit.source_item_revision_id = ir.item_revision_id
     WHERE sit.item_revision_id IN ('. implode(',', $placeholders) .')', $ids);

  while ($item_revision = db_fetch_object($result)) {
    $successor_key = $item_keys[$item_revision->item_revision_id];
    if (!isset($items[$successor_key]->source_items)) {
      $items[$successor_key]->source_items = array();
    }

    $item = new VersioncontrolItem(
      $item_revision->type,
      $item_revision->path,
      $item_revision->revision,
      null,
      $repository
    );
    $item->selected_label = new stdClass();
    $item->selected_label->get_from = 'other_item';
    $item->selected_label->other_item = &$items[$successor_key];
    $item->selected_label->other_item_tags = array('successor_item');

    // Insert the item and its associated action into the successor item.
    if ($item_revision->action == VERSIONCONTROL_ACTION_REPLACED) {
      $items[$successor_key]->replaced_item = $item;
    }
    else if ($item_revision->action == VERSIONCONTROL_ACTION_ADDED) {
      $items[$successor_key]['action'] = $item_revision->action;
      // Added items only join to an empty (NULL) item, ignore that one
      // instead of adding it to the source items.
    }
    else {
      $items[$successor_key]->action = $item_revision->action;
      $items[$successor_key]->source_items[$item->path] = $item;
    }

    // Add the lines-changed information if it has been recorded.
    // Only a single source item entry should hold this information,
    // so no emphasis is placed on merging it across multiple source items.
    if ($item_revision->line_changes_recorded) {
      $items[$successor_key]->line_changes = array(
        'added' => $item_revision->line_changes_added,
        'removed' => $item_revision->line_changes_removed,
      );
    }
  }
}

/**
 * Retrieve additional information about the successors of a given set
 * of items.
 *
 * @param $repository
 *   The repository that the items are located in.
 * @param $items
 *   An array of item arrays, for example as returned by
 *   versioncontrol_get_operation_items().
 *
 * @return
 *   This function does not have a return value; instead, it alters the
 *   given item arrays and adds additional information about their successors.
 *   The following elements will be set for all items whose successor items
 *   could be retrieved.
 *
 *   - 'successor_items': An array with the previous revision(s) of the
 *        affected item. The key for all items in this array is the respective
 *        item path, and all of these items will have the 'actions' and
 *        'source_items' properties (as documented by
 *        versioncontrol_fetch_source_items()) filled in.
 *   - 'replaced_by_item': The succeeding but technically unrelated item at the
 *        same location as the current item. Only exists if the original item
 *        was deleted and replaced by a the succeeding one that was just moved
 *        or copied to this location.
 */
function versioncontrol_fetch_successor_items($repository, &$items) {
  if (empty($items)) {
    return;
  }
  $placeholders = array();
  $ids = array();
  $item_keys = array();

  foreach ($items as $key => $item) {
    // If we don't yet know the item_revision_id (required for db queries), try
    // to retrieve it. If we don't find it, we can't fetch this item's sources.
    if (versioncontrol_fetch_item_revision_id($repository, $item)) {
      $placeholders[] = '%d';
      $ids[] = $item['item_revision_id'];
      $item_keys[$item['item_revision_id']] = $key;
    }
  }

  $result = db_query(
    'SELECT sit.item_revision_id, sit.source_item_revision_id, sit.action,
            ir.path, ir.revision, ir.type
     FROM {versioncontrol_source_items} sit
      INNER JOIN {versioncontrol_item_revisions} ir
       ON sit.item_revision_id = ir.item_revision_id
     WHERE sit.source_item_revision_id IN ('. implode(',', $placeholders) .')', $ids);

  while ($item_revision = db_fetch_object($result)) {
    $source_key = $item_keys[$item_revision->source_item_revision_id];
    if (!isset($items[$source_key]['successor_items'])) {
      $items[$source_key]['successor_items'] = array();
    }

    $item = array(
      'path' => $item_revision->path,
      'revision' => $item_revision->revision,
      'type' => $item_revision->type,
      'item_revision_id' => $item_revision->item_revision_id,
    );
    $item['selected_label'] = new stdClass();
    $item['selected_label']->get_from = 'other_item';
    $item['selected_label']->other_item = &$items[$source_key];
    $item['selected_label']->other_item_tags = array('source_item');

    // Insert the item and its associated action into the source item.
    if ($item_revision->action == VERSIONCONTROL_ACTION_REPLACED) {
      $items[$source_key]['replaced_by_item'] = $item;
    }
    else {
      if ($item_revision->action == VERSIONCONTROL_ACTION_MERGED) {
        // If we've got a merge action then there are multiple source items,
        // the one that we know is not sufficient. (And of course, we won't
        // return an item with an incomplete 'source_items' property.)
        // So let's retrieve all of those source items.
        $successor_items = array($item['path'] => $item);
        versioncontrol_fetch_source_items($repository, $successor_items);
        $item = $successor_items[$item['path']];
      }
      else { // No "merged" action: the original item is the only source item.
        $item['action'] = $item_revision->action;
        $item['source_items'] = array(
          $items[$source_key]['path'] => $items[$source_key],
        );
      }
      $items[$source_key]['successor_items'][$item['path']] = $item;
    }
  }
}

/**
 * Retrieve the VCS username for a given Drupal user id in a specific
 * repository. If you need more detailed querying functionality than this
 * function provides, use VersioncontrolAccount::getAccounts() instead.
 *
 * @param $repo_id
 *   The repository id of the repository where the user has its VCS account.
 * @param $username
 *   The VCS specific username (a string) corresponding to the Drupal user.
 * @param $include_unauthorized
 *   If FALSE (which is the default), this function does not return accounts
 *   that are pending, queued, disabled, blocked, or otherwise non-approved.
 *   If TRUE, all accounts are returned, regardless of their status.
 *
 * @return
 *   The Drupal user id that corresponds to the given username and repository,
 *   or NULL if no Drupal user could be associated to those.
 */
function versioncontrol_get_account_uid_for_username($repo_id, $username, $include_unauthorized = FALSE) {
  $result = db_query("SELECT uid, repo_id
                      FROM {versioncontrol_accounts}
                      WHERE username = '%s' AND repo_id = %d",
                      $username, $repo_id);

  while ($account = db_fetch_object($result)) {
    $repository = VersioncontrolRepository::getRepository($account->repo_id);
    // Only include approved accounts, except in case the caller said otherwise.
    if ($include_unauthorized || versioncontrol_is_account_authorized($repository, $account->uid)) {
      return $account->uid;
    }
  }
  return NULL;
}

/**
 * Retrieve the Drupal user id for a given VCS username in a specific
 * repository. If you need more detailed querying functionality than this
 * function provides, use VersioncontrolAccount::getAccounts() instead.
 *
 * @param $repo_id
 *   The repository id of the repository where the user has its VCS account.
 * @param $uid
 *   The Drupal user id corresponding to the VCS account.
 * @param $include_unauthorized
 *   If FALSE (which is the default), this function does not return accounts
 *   that are pending, queued, disabled, blocked, or otherwise non-approved.
 *   If TRUE, all accounts are returned, regardless of their status.
 *
 * @return
 *   The VCS username (a string) that corresponds to the given Drupal user
 *   and repository, or NULL if no VCS account could be associated to those.
 */
function versioncontrol_get_account_username_for_uid($repo_id, $uid, $include_unauthorized = FALSE) {
  $result = db_query('SELECT uid, username, repo_id
                      FROM {versioncontrol_accounts}
                      WHERE uid = %d AND repo_id = %d',
                      $uid, $repo_id);

  while ($account = db_fetch_object($result)) {
    $repository = VersioncontrolRepository::getRepository($account->repo_id);
    // Only include approved accounts, except in case the caller said otherwise.
    if ($include_unauthorized || versioncontrol_is_account_authorized($repository, $account->uid)) {
      return $account->username;
    }
  }
  return NULL;
}

/**
 * Retrieve the URL of the repository viewer that displays the given commit
 * in the corresponding repository.
 *
 * @param $operation
 *   The commit operation whose view URL should be retrieved.
 *
 * @return
 *   The commit view URL corresponding to the given arguments.
 *   An empty string is returned if no commit view URL has been defined,
 *   or if the commit cannot be viewed for any reason.
 */
function versioncontrol_get_url_commit_view($operation) {
  if (empty($operation->revision)) {
    return '';
  }
  $urls = _versioncontrol_get_repository_urls($operation->repository);
  return strtr($urls['commit_view'], array(
    '%revision' => $operation->revision,
  ));
}

/**
 * Retrieve the URL of the repository viewer that displays the commit log
 * of the given item in the corresponding repository. If no such URL has been
 * specified by the user, the appropriate URL from the Commit Log module is
 * used as a fallback (if that module is enabled).
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose log view URL should be retrieved.
 *
 * @return
 *   The item log view URL corresponding to the given arguments.
 *   An empty string is returned if no item log view URL has been defined
 *   (and if not even Commit Log is enabled), or if the item cannot be viewed
 *   for any reason.
 */
function versioncontrol_get_url_item_log_view($repository, &$item) {
  $urls = _versioncontrol_get_repository_urls($repository);
  //FIXME refactor item method to oop
  $label = $item->getSelectedLabel($repository, $item);

  if (isset($label['type']) && $label['type'] == VERSIONCONTROL_OPERATION_BRANCH) {
    $current_branch = $label['name'];
  }

  if (!empty($urls['file_log_view'])) {
    if (versioncontrol_is_file_item($item)) {
      return strtr($urls['file_log_view'], array(
        '%path'     => $item['path'],
        '%revision' => $item['revision'],
        '%branch'   => isset($current_branch) ? $current_branch : '',
      ));
    }
    // The default URL backend doesn't do log view URLs for directory items:
    return '';
  }
  else if (module_exists('commitlog')) { // fallback, as 'file_log_view' is empty
    $query = array(
      'repos' => $repository['repo_id'],
      'paths' => drupal_urlencode($item['path']),
    );
    if (isset($current_branch)) {
      $query['branches'] = $current_branch;
    }
    return url('commitlog', array(
      'query' => $query,
      'absolute' => TRUE,
    ));
  }
  return ''; // in case we really can't retrieve any sensible URL
}

/**
 * Retrieve the URL of the repository viewer that displays the contents of the
 * given item in the corresponding repository.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose view URL should be retrieved.
 *
 * @return
 *   The item view URL corresponding to the given arguments.
 *   An empty string is returned if no item view URL has been defined,
 *   or if the item cannot be viewed for any reason.
 */
function versioncontrol_get_url_item_view($repository, &$item) {
  $urls = _versioncontrol_get_repository_urls($repository);
  $label = $item->getSelectedLabel($repository, $item);

  if (isset($label['type']) && $label['type'] == VERSIONCONTROL_OPERATION_BRANCH) {
    $current_branch = $label['name'];
  }
  $view_url = $item->isFile()
              ? $urls['file_view']
              : $urls['directory_view'];

  return strtr($view_url, array(
    '%path'     => $item['path'],
    '%revision' => $item['revision'],
    '%branch'   => isset($current_branch) ? $current_branch : '',
  ));
}

/**
 * Retrieve the URL of the repository viewer that displays the diff between
 * two given files in the corresponding repository.
 *
 * @param $repository
 *   The repository that the file items are located in.
 * @param $file_item_new
 *   The new version of the file that should be diffed.
 * @param $file_item_old
 *   The old version of the file that should be diffed.
 *
 * @return
 *   The diff URL corresponding to the given arguments.
 *   An empty string is returned if no diff URL has been defined,
 *   or if the two items cannot be diffed for any reason.
 */
function versioncontrol_get_url_diff($repository, &$file_item_new, $file_item_old) {
  $urls = _versioncontrol_get_repository_urls($repository);
  $label = versioncontrol_get_item_selected_label($repository, $file_item_new);

  if (isset($label['type']) && $label['type'] == VERSIONCONTROL_OPERATION_BRANCH) {
    $current_branch = $label['name'];
  }
  return strtr($urls['diff'], array(
    '%path'         => $file_item_new['path'],
    '%new-revision' => $file_item_new['revision'],
    '%old-path'     => $file_item_old['path'],
    '%old-revision' => $file_item_old['revision'],
    '%branch'       => isset($current_branch) ? $current_branch : '',
  ));
}

/**
 * Retrieve the URL of the issue tracker that displays the issue/case/bug page
 * of an issue id which presumably has been mentioned in a commit message.
 * As issue tracker URLs are specific to each repository, this also needs
 * to be given as argument.
 *
 * @param $repository
 *   The repository that is covered by the issue tracker.
 * @param $issue_id
 *   A number that uniquely identifies the mentioned issue/case/bug.
 *
 * @return
 *   The issue tracker URL corresponding to the given arguments.
 *   An empty string is returned if no issue tracker URL has been defined.
 */
function versioncontrol_get_url_tracker($repository, $issue_id) {
  $urls = _versioncontrol_get_repository_urls($repository);
  return strtr($urls['tracker'], array('%d' => $issue_id));
}

/**
 * Retrieve the repository viewer URLs from the database (or from the cache).
 *
 * @param $repository
 *   The repository for which the URLs should be retrieved.
 *
 * @return
 *   A structured array with the repository viewer URLs as values (each of them
 *   can be an empty string), corresponding to the following keys:
 *
 *   - 'commit_view': The overall summary view of a commit/revision.
 *   - 'file_view': The 'view' URL of a file in the repository.
 *   - 'directory_view': The 'view' URL of a directory in the repository.
 *   - 'diff': The difference between two versions of a file
 *        (or of two different files, if the repository viewer supports it).
 *   - 'tracker': The issue/bug/case URL of the associated issue tracker.
 */
function _versioncontrol_get_repository_urls($repository) {
  static $urls_by_repository = array();

  if (!isset($urls_by_repository[$repository->repo_id])) {
    $result = db_query('SELECT * FROM {versioncontrol_repository_urls}
                        WHERE repo_id = %d', $repository->repo_id);

    while ($urls = db_fetch_array($result)) {
      unset($urls['repo_id']);
      $urls_by_repository[$repository->repo_id] = $urls;
    }
  }
  if (!isset($urls_by_repository[$repository->repo_id])) {
    return array(
      'commit_view' => '', 'file_view' => '', 'directory_view' => '',
      'diff' => '', 'tracker' => '',
    );
  }
  return $urls_by_repository[$repository->repo_id];
}


/**
 * Get the user-visible version of a revision identifier (for an operation or
 * an item), as plaintext. By default, this function simply returns $revision.
 *
 * Version control backends can, however, choose to implement their own version
 * of this function, which for example makes it possible to cut the SHA-1 hash
 * in distributed version control systems down to a readable length.
 *
 * @param $repository
 *   The repository array for the repository where the revision is located.
 * @param $revision
 *   The unformatted revision, as given in $operation['revision']
 *   or $item['revision'] (or the respective table columns for those values).
 * @param $format
 *   Either 'full' for the original version, or 'short' for a more compact form.
 *   If the revision identifier doesn't need to be shortened, the results can
 *   be the same for both versions.
 */
function versioncontrol_format_revision_identifier($repository, $revision, $format = 'full') {
  if (versioncontrol_backend_implements($repository->vcs, 'format_revision_identifier')) {
    return _versioncontrol_call_backend(
      $repository->vcs, 'format_revision_identifier', array($repository, $revision, $format)
    );
  }
  return $revision;
}

/**
 * Get the user-visible version of a commit identifier a.k.a. 'revision',
 * as plaintext. By default, this function returns the operation's revision
 * if that property exists, or its vc_op_id identifier as fallback.
 *
 * Version control backends can, however, choose to implement their own version
 * of this function, which for example makes it possible to cut the SHA-1 hash
 * in distributed version control systems down to a readable length.
 *
 * @param $operation
 *   The operation whose commit identifier should be themed.
 * @param $format
 *   Either 'full' for the original version, or 'short' for a more compact form.
 *   If the commit identifier doesn't need to be shortened, the results can
 *   be the same for both versions.
 */
function versioncontrol_format_operation_revision_identifier($operation, $format = 'full') {
  if (empty($operation->revision)) {
    return '#'. $operation->vc_op_id;
  }
  return versioncontrol_format_revision_identifier($operation->repository, $operation->revision, $format);
}

/**
 * Get the user-visible version of an item's revision identifier, as plaintext.
 * By default, this function simply returns $item['revision'].
 *
 * Version control backends can, however, choose to implement their own version
 * of this function, which for example makes it possible to cut the SHA-1 hash
 * in distributed version control systems down to a readable length.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $item
 *   The item whose revision identifier should be themed.
 * @param $format
 *   Either 'full' for the original version, or 'short' for a more compact form.
 *   If the revision identifier doesn't need to be shortened, the results can
 *   be the same for both versions.
 */
function versioncontrol_format_item_revision_identifier($repository, $item, $format = 'full') {
  return versioncontrol_format_revision_identifier($repository, $item['revision']);
}


/**
 * Try to retrieve a given item in a repository.
 *
 * This function is optional for VCS backends to implement, be sure to check
 * with versioncontrol_backend_implements($repository['vcs'], 'get_item')
 * if the particular backend actually implements it.
 *
 * @param $repository
 *   The repository that the item is located in.
 * @param $path
 *   The path of the requested item.
 * @param $constraints
 *   An optional array specifying one of two possible array keys which specify
 *   the exact revision of the item:
 *
 *   - 'revision': A specific revision for the requested item, in the same
 *        VCS-specific format as $item['revision']. A repository/path/revision
 *        combination is always unique, so no additional information is needed.
 *   - 'label': A label array with at least 'name' and 'type' elements
 *        filled in. If a label is provided, it should be incorporated into the
 *        result item as 'selected_label' (see return value docs), and will
 *        cause the most recent item on the label to be fetched. If the label
 *        includes an additional 'date' property holding a Unix timestamp, the
 *        item at that point of time will be retrieved instead of the most
 *        recent one. (For tag labels, there is only one item anyways, so
 *        nevermind the "most recent" part in that case.)
 *
 * @return
 *   If the item with the given path and revision cannot be retrieved, NULL is
 *   returned. Otherwise the result is an item array, consisting of the
 *   following elements:
 *
 *   - 'type': Specifies the item type, which is either
 *        VERSIONCONTROL_ITEM_FILE or VERSIONCONTROL_ITEM_DIRECTORY for items
 *        that still exist, or VERSIONCONTROL_ITEM_FILE_DELETED respectively
 *        VERSIONCONTROL_ITEM_DIRECTORY_DELETED for items that have been
 *        removed.
 *   - 'path': The path of the item at the specific revision.
 *   - 'revision': The currently selected (file-level) revision of the item.
 *        If there is no such revision (which may be the case for directory
 *        items) then the 'revision' element is an empty string.
 *
 *   If the returned item is already present in the database, the
 *   'item_revision_id' database identifier might also be filled in
 *   (optionally, depending on the VCS backend).
 */
function versioncontrol_get_item($repository, $path, $constraints = array()) {
  $info = _versioncontrol_call_backend(
    $repository['vcs'], 'get_item', array($repository, $path, $constraints)
  );
  if (empty($info)) {
    return NULL;
  }
  $item = $info['item'];
  $item['selected_label'] = new stdClass();
  $item['selected_label']->label = is_null($info['selected_label'])
                                    ? FALSE : $info['selected_label'];
  return $item;
}

/**
 * Retrieve the deepest-level directory path in the repository that is common
 * to all the given items, e.g. '/src' if there are two items with the paths
 * '/src/subdir/code.php' and '/src/README.txt', or '/' for items being located
 * at '/src/README.txt' and '/doc'.
 *
 * @param $items
 *   An array of items of which the common directory path should be retrieved.
 *
 * @return
 *   The common directory path of all given items. If no items were passed,
 *   the root directory path '/' will be returned.
 */
function versioncontrol_get_common_directory_path($items) {
  if (empty($items)) {
    return '/';
  }
  $paths = _versioncontrol_get_item_paths($items);

  $dirparts = explode('/', dirname(array_shift($paths)));

  foreach ($paths as $path) {
    $new_dirparts = array();
    $current_dirparts = explode('/', dirname($path));
    $mincount = min(count($dirparts), count($current_dirparts));

    for ($i = 0; $i < $mincount; $i++) {
      if ($dirparts[$i] == $current_dirparts[$i]) {
        $new_dirparts[] = $dirparts[$i];
      }
      else {
        break;
      }
    }
    $dirparts = $new_dirparts;
  }

  if (count($dirparts) == 1) {
    return '/';
  }
  return implode('/', $dirparts);
}

function _versioncontrol_get_item_paths($items) {
  $paths = array();
  // Store the paths as keys and return the array_keys() afterwards,
  // in order to get automatic removal of duplicates.
  foreach ($items as $item) {
    $paths[$item['path']] = TRUE;
  }
  return array_keys($paths);
}

/**
 * Return TRUE if @p $parent_path is a parent directory path of @p $child_path.
 */
function versioncontrol_path_contains($parent_path, $child_path) {
  if ($parent_path == $child_path) {
    return TRUE;
  }
  if ($parent_path != '/') {
    $parent_path .= '/';
  }
  return (strpos($child_path, $parent_path) === 0);
}


/**
 * Return a the username of a VCS account.
 *
 * @param $uid
 *   The Drupal user id of the user. If this is 0, the corresponding
 *   Drupal user naturally can't be retrieved, with all implications for
 *   displaying the username.
 * @param $username
 *   The VCS username for the account.
 * @param $repository
 *   The repository where this account is registered.
 * @param $options
 *   An array of options that further influence the output format:
 *
 *   - 'prefer_drupal_username': By default, this function tries to get the
 *        corresponding Drupal user for the supplied uid and returns the
 *        "real" username rather than the given one. If this is set to FALSE,
 *        the given VCS username is always returned.
 *   - 'format': By default, the username will be linked to the user page
 *        (for Drupal users) or to the commit log page containing the user's
 *        commits (for unassociated accounts). If 'plaintext', the username
 *        will be returned without markup.
 *   - 'include_repository_name': By default, an account that is not associated
 *        to a Drupal user will get the repository name appended in order to
 *        make for a unique account descriptor. If this option is set to TRUE,
 *        the repository name will be suppressed anyways.
 */
function theme_versioncontrol_account_username($uid, $username, $repository, $options = array()) {
  $prefer_drupal_username = isset($options['prefer_drupal_username'])
    ? $options['prefer_drupal_username']
    : TRUE;
  $format = isset($options['format']) ? $options['format'] : 'html';

  if ($uid && $prefer_drupal_username) {
    $user = user_load($uid);

    if ($user && $prefer_drupal_username) {
      return ($format == 'html') ? theme('username', $user) : $user->name;
    }
  }

  if (!empty($options['include_repository_name'])) {
    $username = t('!user @ !repository', array(
      '!user' => $username,
      '!repository' => $repository['name'],
    ));
  }
  if ($format == 'html' && module_exists('commitlog')) {
    return l($username, commitlog_get_account_url($repository, $username));
  }
  return $username;
}

/**
 * Return a table of contributors for the specified per-user statistics.
 *
 * @param $statistics
 *   An array of statistics objects as returned by
 *   versioncontrol_get_operation_statistics(), grouped by at least uid and
 *   optionally repo_id/username columns.
 * @param $options
 *   An array of optional further options. Currently, the only supported
 *   array key is 'constraints' which contains the operation constraints used
 *   to determine these statistics. If given, the "Commits" column in the table
 *   will link to the contributor's commits in addition to displaying the
 *   commit count.
 */
function theme_versioncontrol_user_statistics_table($statistics, $options = array()) {
  $header = array(t('User'), t('Last commit'), t('First commit'), t('Commits'));
  $rows = array();

  foreach ($statistics as $user_stats) {
    $last_operation_date = t('!time ago', array(
      '!time' => format_interval(time() - $user_stats->last_operation_date, 1),
    ));
    $first_operation_date = t('!time ago', array(
      '!time' => format_interval(time() - $user_stats->first_operation_date, 1),
    ));
    $total_operations = format_plural(
      $user_stats->total_operations, '1 commit', '@count commits'
    );

    if (isset($options['constraints']) && module_exists('commitlog')) {
      if (isset($user_stats->repo_id) && isset($user_stats->username)) {
        $options['constraints']['repo_ids'] = array($user_stats->repo_id);
        $options['constraints']['usernames'] = array($user_stats->username);
      }
      else {
        $options['constraints']['uids'] = array($user_stats->uid);
      }
      $total_operations = l($total_operations, commitlog_get_url($options['constraints']));
    }

    $rows[] = array(
      theme('versioncontrol_user_statistics_account', $user_stats),
      $last_operation_date,
      $first_operation_date,
      $total_operations,
    );
  }
  return theme('table', $header, $rows);
}

/**
 * Return a condensed item list of contributors for the specified per-user
 * statistics. An empty string is returned if the given array is empty.
 *
 * @param $statistics
 *   An array of statistics objects as returned by
 *   versioncontrol_get_operation_statistics(), grouped by at least uid and
 *   optionally repo_id/username columns.
 */
function theme_versioncontrol_user_statistics_item_list($statistics, $more_link = NULL) {
  $items = array();

  if (empty($statistics)) {
    return '';
  }
  drupal_add_css(drupal_get_path('module', 'versioncontrol') . '/versioncontrol.css');

  foreach ($statistics as $user_stats) {
    $item = '<div class="versioncontrol-committer-item">';
    $item .= t('!committer - !commit-count', array(
      '!committer' => theme('versioncontrol_user_statistics_account', $user_stats),
      '!commit-count' => '<span class="versioncontrol-commit-count">'
        . format_plural($user_stats->total_operations, '1 commit', '@count commits')
        . '</span>',
    ));

    if (!empty($user_stats->first_operation_date)) { // has committed yet?
      $item .= '<div class="versioncontrol-commit-times">';
      $item .= t('last: !last_time ago, first: !first_time ago', array(
        '!last_time' => format_interval(time() - $user_stats->last_operation_date, 1),
        '!first_time' => format_interval(time() - $user_stats->first_operation_date, 1),
      ));
      $item .= '</div>';
    }
    $item .= '</div>';
    $items[] = $item;
  }

  $output = theme('item_list', $items);
  if (!empty($more_link)) {
    $output .= $more_link;
  }
  return $output;
}

/**
 * Given a single statistics object (including uid for the Drupal user and
 * optionally a repo_id/username combination), return a themed version of the
 * corresponding user.
 */
function theme_versioncontrol_user_statistics_account($user_stats) {
  if (isset($user_stats->repo_id) && isset($user_stats->username)) {
    $repository = VersioncontrolRepository::getRepository($user_stats->repo_id);
    return theme('versioncontrol_account_username',
      $user_stats->uid, $user_stats->username, $repository,
      array('include_repository_name' => TRUE)
    );
  }
  else {
    $committer = user_load($user_stats->uid);
    return theme('username', $committer);
  }
}


/**
 * Implementation of hook_block():
 * Present a list of the most active developers.
 */
function versioncontrol_block($op = 'list', $delta = 0) {
  if ($op == 'list') {
    $blocks = array();
    $blocks['site_active_developers'] = array(
      'info' => t('Version Control API: Most active developers'),
      'cache' => BLOCK_CACHE_GLOBAL,
    );
    return $blocks;
  }
  else if ($op == 'view') {
    if ($delta == 'site_active_developers') {
      return versioncontrol_block_site_active_developers();
    }
  }
}

/**
 * Implementation of hook_block($op='view') for the "active developers" block.
 */
function versioncontrol_block_site_active_developers() {
  $block = array();
  $interval = 7 * 24 * 60 * 60;
  $length = 15;

  $result = db_query_range('
    SELECT COUNT(op.vc_op_id) AS count, op.uid, u.name
    FROM {versioncontrol_operations} op
      INNER JOIN {users} u
        ON op.uid = u.uid AND op.uid != 0 AND op.date > %d
    WHERE op.type = %d
    GROUP BY op.uid, u.name ORDER BY count DESC',
    array(time() - $interval, VERSIONCONTROL_OPERATION_COMMIT), // placeholders
    0, $length // query range arguments: 'from' and 'count'
  );

  $usernames = array();
  while ($user = db_fetch_object($result)) {
    $usernames[] = theme('username', $user);
  }
  if (!empty($usernames)) {
    $block = array(
      'subject' => t('Most active developers'),
      'content' => theme('item_list', $usernames),
    );
  }
  return $block;
}


/**
 * Returns a string of suggestions for Drupal usernames with accounts for
 * the given repository, formatted to be suitable for use with
 * JS autocomplete fields.
 */
function versioncontrol_user_autocomplete($repo_id, $string = '') {
  if (!is_numeric($repo_id) || empty($string)) {
    drupal_json(array());
    return;
  }
  $matches = array();
  $result = db_query_range("SELECT u.uid, u.name
                            FROM {users} u
                             INNER JOIN {versioncontrol_accounts} a
                              ON u.uid = a.uid
                            WHERE repo_id = %d
                             AND LOWER(u.name) LIKE LOWER('%s%%')",
                            $repo_id, $string, 0, 10);

  while ($user = db_fetch_object($result)) {
    if (!isset($repository)) {
      $repository = VersioncontrolRepository::getRepository($repo_id);
    }
    if (versioncontrol_is_account_authorized($repository, $user->uid)) {
      $matches[$user->name] = check_plain($user->name);
    }
  }
  drupal_json($matches);
}


/**
 * Return preset values for strings that are used in the user interface.
 */
function _versioncontrol_get_string_presets() {
  $presets = array();

  $presets['versioncontrol_registration_message_unauthorized'] = t('<p>The Concurrent Versioning System (CVS) is a software development tool available to volunteers with experience in software development, translation, theming, or documentation who wish to participate in the Drupal project.</p>
<p>To request access to the Drupal CVS repository you must <a href="!register">create an account</a> and <a href="!login">login</a>. Come back to this page after you have logged on.</p>',
    array('!register' => url('user/register'), '!login' => url('user/login'))
  );

  $presets['versioncontrol_registration_message_authorized'] = t('<p>The Concurrent Versioning System (CVS) is a software development tool available to volunteers with experience in software development, translation, theming, or documentation who wish to participate in the Drupal project.</p>
<p>A version control system account is not required to contribute patches to the Drupal project or community contributed projects. Anonymous access to the Drupal CVS repository is available which can be used to accomplish this. Please peruse the <a href="!handbook">CVS handbook</a> and <a href="!patch">patch guide</a> for more information.</p>
<p>If you are an open source software developer, themer, translator or documentation writer, please choose one of Drupal\'s repositories from the selection below in order to request commit access to this repository. Prior to applying, please ensure that:</p>
<ul>
  <li>you have a concrete idea as to what you intend to contribute.</li>
  <li>you are not duplicating any <a href="!projects">existing projects</a>.</li>
</ul>',
    array('!projects' => url('project'), '!handbook' => url('handbook/cvs'), '!patch' => url('patch'))
  );

  $presets['versioncontrol_registration_message_repository'] = t('<p>The Concurrent Versioning System (CVS) is a software development tool available to volunteers with experience in software development, translation, theming, or documentation who wish to participate in the Drupal project.</p>
<p>A version control system account is not required to contribute patches to the Drupal project or community contributed projects. Anonymous access to the Drupal CVS repository is available which can be used to accomplish this. Please peruse the <a href="!handbook">CVS handbook</a> and <a href="!patch">patch guide</a> for more information.</p>
<p>If you are an open source software developer, themer, translator or documentation writer, please use the form below to create an account in Drupal\'s CVS repository. Prior to registering, please ensure that:</p>
<ul>
  <li>you have a concrete idea as to what you intend to contribute.</li>
  <li>you are not duplicating any <a href="!projects">existing projects</a>.</li>
</ul>',
    array('!projects' => url('project'), '!handbook' => url('handbook/cvs'), '!patch' => url('patch'))
  );

  return $presets;
}
